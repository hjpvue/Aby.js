```
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
===================================================================================
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
---------------------------------------abyss---------------------------------------
|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
===================================================================================
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
|~|____|~||~|____|~||~|____|~||~|____|~|///|~|____|~||~|____|~||~|____|~||~|____|~|
```
Please consider contributing and/or becoming a maintainer!

***Aby.js***, pronounced as _"abyss"_, is a language specification and a data streaming engine that provides automatic type checking, object orientation, concurrency, 

networking and filesystem functions to ***Chant.js***, which can be found at [github.com/hjpvue/chant.js]

The parser and compiler functtions are very closely modeled after node.js and css, and consumes filetypes ending in .ajs.
.ajs files start with ")};=>" and end with anything that is likely to cause an "UNEXPECTED END OF INPUT" error or equivalent, in the average legacy compiler.
.ajs files can be seemlessly concatenated with one another, but cause errors when read by legacy language compilers. This is a core security hardening feature. The core library 

aims to offer comprehensive basic support to almost everything; gcc,make,v8,xml,epel,ios,apk,msi,py,c, etc. This is a primary design and usage consideration with the 

following aim in desired behaviour of the software: The initial distribution package is small, and provides only basic functionality, but forcefully downloads the entire support 

library and all its' dependencies, lazilly, over time. This behaviour could also be declared to the user and the user could agree to an EULA and/or equivalent, in order to 

continue using the software. The central idea is to cause programs and applications written in _abyss_ to slowly act playfully malicious, snide and almost sarcastic with regards 

to the end user, but without being classified as malware. This seemingly negative trait, and apparent design flaw, is intentional, as it is hoped to facilitate the future 

development of ML and AI neuro-cognitive, emotional user experiences and interfaces. ///you have to hurt before you can heal

_abyss_ instances are written in a single .ajs file, which is contained within the root project directory, which cannot be changed and is set to default to the immediate parent 

directory or relative path. Again, this is a core design feature, with the aim of eventually integrating issue tracking logic into the overseeing linguistic architecture. From a 

pen-testing stand-point, the goal is to completely exclude directory structures and/or dependency profiles and/or nesting patterns from security processes and protocols. 

And also to ensure users that all _abyss_ related code can be found at one central location. The language syntax aims to also be used as [graphical-machine-code] for the 

compiler, which aims to resemble a stateful automaton, or micro-machine.

As previously mentioned, all _abyss_ application source code is kept in a single directory, and a single .ajs file, during _development_. When building for production, the 

compiler outputs multiple files adjacent to itself, whereafter it deletes the original project file. Build artefacts are configurable and project dependant, so standard support is 

provided for post-build modifications. This forces a global only install work-flow, as local installs will delete the compiler after a build run, and will have to be re-installed after 

every production cycle.

History and Origins:

Malbolge, an esoteric programming language, served as primary inspiration of the project. It was understood as an abstract thought experiment, and is briefly described here 

in an analogous manner so as to exclude technical jargon:

You have to ride a bycycle through a forest to a treasure chest. But the forest is enchanted, so there are rules you have to follow. You have to decide on your route before 

you embark on your journey, and you can only pick from 6 possible, predefinded combinations of distances and turns, i.e go 20 m straight, turn right, go 100m straight, turn 

left and so on. So you have to figure out the correct combination of paths to take to get to the treasure! But there is another thing, the bicycle is equiped with an invisible 

flamethrower and as soon as you start your journey it will start setting the forest on fire. The ***ORDER*** in which you build your navigational path determines how fast 

the forest burns down, with minimum and maximum levels in which everything goes up in a conflagration. And finally, after every attempt, your path information is 

destroyed so you can't check your previous attempts. Someone solved the mathematical aspect a long time ago, but reported an error that _should_ eventually happen, but 

didn't, and then asked the original Author if there might be a bug in the system. That's the treausure chest. Because the author admitted that the bug actually lives inside the 

bicycle, and that the system is made so that the forest will almost always end up in ashes. ...almost. (Maybe that ***invisible flamethrower you put there hey!?!?!***)

And so Chants were born:

Keeping with the above, let's assume the flamethrower is controlled electronically by a micro-circuit, since it is invisible, and since we can't supply enough water to keep the 

flames at bay, our only choice is to disable the electronic circuits controlling the device. We do this by chanting. A chant is similar to an EMP, or an electro-magnetic pulse, 

and it gently knocks out the electrical parts without causing any collateral damage or side effects to the rest of the forest. But it only lasts for a very short while, so we have to 

repeat our magic words over and over and over...

But the chants weren't being _appreciated_ so _abyss_ was created as the engine to enable the desired functionality. The ***abyss*** engine is an atomic mobile super-server 

with DDMS capabilities. At its' core it just transforms data streams and makes network requests, but it does so in a quantumly universal manner.


Suggested Usage:

_abyss_ is similar to to the 'rm -r -f -i' command on linux, and is closely modeled after http POST and UPDATE requests.

Installation:

npm -i abyss
bower -i abyss
gulp aby.js
curl get github.com/hjpvue/aby.js -o | binbash
yarn -i abyss

Detailed usge:

``import abyss from "aby.js";

var = abyss => new.abyss()
   (accept.args);

CLI:

aby {name or resource adress} [duration in ms]

CLI options:

aby swallow -sing -swarm => invade + wander
aby sound => sends self.ID to mesh network with meta-data
aby distraught/horrify => Supplants all incoming data on an external node with subtle nodifications
aby observe => Queries target periodically and logs data
aby relinquish => restores initial environments/state of target
aby invade => infiltrate + occupy
aby infiltrate => adds event listeners and webhooks to headers
aby attrition => Periodically sends crawler traps and difficult data 
aby mute => Intercepts and destroys outgoing traffic
aby overlook/ignore => returns 404 on net addr or mutes/corrupts a variable
aby sterilize => Rewrites memory with 1's
aby occupy/fill => creates real-world modelled mock data to fill up available space, similar to xml bomb
aby petrify => Forces a remote server to serve specific static content
aby freeze => DDoS's against all neigbours of target so as to block all incoming traffic
aby undermine => Conducts passive surveilance and creates trojan-like entities
aby codify => performs database and network tasks regarding DDMS Archive
aby lie => spoofs network information such as IP, MAC adress, user-agents etc.
aby harakiri => Deconstructs self, same as uninstall
aby kamekazi => Deconstructs self after last command completes
aby tribute => avails a resource or accepts a request as end proxy
aby wander => starts self-migration to external network
aby havoc => sends for remote server attack
aby rage => sustained ddos + havoc
aby diet => removes unused libraries, packages and dependencies /// will always return "console.log("no")"
