The abyss language, written by Hendrik Pretorius, is a hyper-abstraction of its' preceding languages, thus allowing for the following properties of the "hello world" .ajs file:

*2 applications
*Multiple-API's
*3 configurations
*Relational, embedded database
*Multi-dimensional, embedded arrays

Because of the nature of the compiler, "quantum universality" is possible, and therefore allows for unlimited expansion with respect to the contents, the only limitation being the underlying filesystem constraints of the system that is running the abyss implementation. The compiler is written in Node13x. The compiler can be configured to operate in an unlimited number of ways, thus allowing for extensibility of every part of the language, and therefore affording support for industrial software integrations, as well as academic use-cases including, but not limited to:

*Artificial Intellegence
*Machine Learning
*Cloud Computing
*Self-repairing architectures
*Big Data Management
*Supercomputing

Apllications written in abyss are essentially composed of an entire micro-net of possibly fully fledged, virtual operating systems that are able to interact with one another in an autonomous fashion, as well as with the external environment. Owing to the high-level of functional integration and minimisation of language-specific syntax, data-management and storage, as well as self-migration capabilities, are possible, and apparently encouraged as recommended usage by the author.

As abyss relies on a vast amount of higly distant fields of programmatic enquiry, the "helloworld" example, as provided by the author, is discussed here as an example:

{																											}
  "function": "arguments"|--|"variables" :"variables"|--|"function": "arguments"|--|"variables" :"variables"
  "function": "arguments"|--|"variables" :"variables"|--|"function": "arguments"|--|"variables" :"variables"
  "function": "arguments"|--|"variables" :"variables"|--|"function": "arguments"|--|"variables" :"variables"
  "function": "arguments"|--|"variables" :"variables"|--|"function": "arguments"|--|"variables" :"variables"
  "function": "arguments"|--|"variables" :"variables"|--|"function": "arguments"|--|"variables" :"variables"
  "function": "arguments"|--|"variables" :"variables"|--|"function": "arguments"|--|"variables" :"variables"
  }																											{
  "configurations": {|--|} :"meta"
    "lefthand_function": "references"|--|"element", "element", "element"
    "righthand_function": "IP address"|--|"element"
    "general": "references"|--|"element", "element", "element"
  }																											{
  "constants": [
    'a'/'b'/'c'/'d'/'e'/'f'/'g'/'h'/'i'/'j'/'k'/'l'/'m'/'n'/'o'/'p'/'q'/'r'/'s'/'t'/'u'/'v'/'w'/'x'/'y'/'z':
    '0.1'/'0.2'/'0.3'/'0.4'/'0.5'/'0.6'/'0.7'/'0.8'/'0.9'/'0.10'/'0.11'/'0.12'/'0.13'/'0.14'/'0.15'/'0.16'/'0.17'/'0.18'/'0.19'/'0.20'/'0.21'/'0.22'/'0.23'/'0.24'/'0.25'/'0.26'
  ],
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"
  "pointer": "data"  
}																											{

The file consists out of a variety of scaffolding frameworks, owing to its' method of compilation, at a high level, the main file structure is delimited similarly to common network data transfer formats such as JSON, thus allowing easy stringification, encryption, hashing and fast porting of the entire abyss[mal] application. Code segments are divided into blocks, and the compiler reads the file contents in three directions, nl. Left-to-Right, Right-to-Left, as well as vertically.

This multi-dimensional code analysis forms the core of the abyss language, as developers are encouraged to make full functional usage of the minimal amount of resources, whilst not compromising capabilities, and still allowing for easy maintainability and editing by novices. Morphological Analysis is employed to accomplish this, and developers are able to pass instructions indirectly through the code formatting and block arrangements. In the "helloworld" example above, there is a distinct pattern following a language-enforced index of 4,3,2,1 which the compiler interprets as vallues for a 4D-recurring neural network as the parameters {i,j,k,l}, the values of which is determined by the code organisation within the .ajs file.

Atomicity

The first coding block, as the first parser priority, contains the function names and the variable names of the underlying programs, split into individual applications by the language-specific delimiter "|--|". This affords a merciless contraint on the developer, as polyfilling, shimming, or in any way relying on 3rd-party code within an abyss application is constrained by the large impact the chosen amount of contained applications has on higher-level interpretations of the abyss[mal] application. Code written in abyss is challenging to present for proper anaylisis, since it lacks inter-operable modularity with regards to extant tools and techniques, but affords such integrations through the same language-specific delimiter "|--|". Functions and variables are writable throughout an abyss[mal] applications life-cycle, and allows for the dynamic, almost complete re-structuring of an abyss implementation.

|--|

The compiler reads the application architecture on either side of the "|--|" delimiter and dynamically injects an internal websocket based, RESTful API between the "-" symbols. This allows abyss[mal] applications to dynamically share data between each other and/or edit their own data according to network inputs, or internal derivations of the AI sub-systems present in the compiler. Methods and string based syntax have been wholly abstracted, and iterations, loops and conditional statements are declared within the respective data-storage blocks. In that an iterator is programmed and specified by three arbritary variables pointing to each other in a loop. Conditional statements are specified by single variables pointing to the ID's of higher-level tree-like structures, which allow for the usage of Boolean types. Position-based interpretaion allows for the seamles interoperability of strings and integers.

The second coding block contains the configurations of abyss[mal] applications, and the contents are specidied similarly to JSON format. Note that the amount of included configurations is not important, but their order is taken as a compilation instruction, with variations in configuration lenghts being used to implement customised compilation behaviours. Immediatelly following are the mathematical constant definitions such as Pi, and application constants such as product pricing, adress information, network constants etc. The final block contains the multidimensional array data, and is network-read/writable and writable. This trailing end of the .ajs file is used for persistent storage, and is also network-read/writable.